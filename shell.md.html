<!DOCTYPE html>
<!-- saved from url=(0073)file:///C:/Users/Melissa/Downloads/tps%20sisop/TPS-sisop/Lab%20shell.html -->
<html lang="es"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Lab shell</title>
  <meta name="description" content="Sistemas Operativos. Facultad de Ingeniería, Universidad de Buenos Aires.">

  <link rel="stylesheet" href="./shell.md_files/bootstrap.min.css" crossorigin="anonymous" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh">
  <link rel="stylesheet" href="./shell.md_files/main.css">
  <link rel="stylesheet" href="./shell.md_files/all.css">
  <link rel="canonical" href="https://fisop.github.io/website/labs/shell/">
<style>.hiclass {background-color:rgb(51, 144, 255); color: white}</style></head>


  <body>
  <div id="root" class="container-lg">
  <div class="row justify-content-center">

  <!-- Table of contents on the side (see _includes/scripts.html). -->
  <div id="sidetoc" class="col-md-3 d-none px-1 d-md-block">
  <ul class="sidetoc sticky-top nav flex-column">
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#skel" id="markdown-toc-skel" class="nav-link">Esqueleto</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#depurando-con-printf" id="markdown-toc-depurando-con-printf" class="nav-link">Depurando con printf</a></li>
    </ul>
  </li>
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#exec" id="markdown-toc-exec" class="nav-link">Parte 1: Invocación de comandos</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#b%C3%BAsqueda-en-path" id="markdown-toc-búsqueda-en-path" class="nav-link">Búsqueda en <em>$PATH</em></a>        <ul class="nav flex-column">
          <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#argumentos-del-programa" id="markdown-toc-argumentos-del-programa" class="nav-link">Argumentos del programa</a></li>
        </ul>
      </li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#procesos-en-segundo-plano" id="markdown-toc-procesos-en-segundo-plano" class="nav-link">Procesos en segundo plano</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#resumen" id="markdown-toc-resumen" class="nav-link">Resumen</a></li>
    </ul>
  </li>
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#parte-2-redirecciones" id="markdown-toc-parte-2-redirecciones" class="nav-link">Parte 2: Redirecciones</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#flujo-est%C3%A1ndar" id="markdown-toc-flujo-estándar" class="nav-link">Flujo estándar</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#tuber%C3%ADas-simples-pipes" id="markdown-toc-tuberías-simples-pipes" class="nav-link">Tuberías simples <em>(pipes)</em></a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#tuber%C3%ADas-m%C3%BAltiples" id="markdown-toc-tuberías-múltiples" class="nav-link">Tuberías múltiples</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#resumen-1" id="markdown-toc-resumen-1" class="nav-link">Resumen</a></li>
    </ul>
  </li>
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#parte-3-variables-de-entorno" id="markdown-toc-parte-3-variables-de-entorno" class="nav-link">Parte 3: Variables de entorno</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#expandvar" id="markdown-toc-expandvar" class="nav-link">Expansión de variables</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#variables-de-entorno-temporarias" id="markdown-toc-variables-de-entorno-temporarias" class="nav-link">Variables de entorno temporarias</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#pseudo-variables" id="markdown-toc-pseudo-variables" class="nav-link">Pseudo-variables</a></li>
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#resumen-2" id="markdown-toc-resumen-2" class="nav-link">Resumen</a></li>
    </ul>
  </li>
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#parte-4-extras" id="markdown-toc-parte-4-extras" class="nav-link">Parte 4: Extras</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#comandos-built-in" id="markdown-toc-comandos-built-in" class="nav-link">Comandos <em>built-in</em></a></li>
    </ul>
  </li>
  <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#desaf%C3%ADos" id="markdown-toc-desafíos" class="nav-link active">Desafíos</a>    <ul class="nav flex-column">
      <li class="nav-item"><a href="https://fisop.github.io/website/labs/shell/#navegacion-historial" id="markdown-toc-navegacion-historial" class="nav-link active">Navegación por el historial</a></li>
    </ul>
  </li>
</ul></div>

  <!-- Main pane -->
  <div class="col col-md-9 pl-1">
  <div id="pane" class="container-fluid">
    <header role="banner" class="row">
      <nav class="col navbar navbar-light bg-light site-header py-0
            navbar-expand">
  <a class="navbar-brand mr-auto" href="https://fisop.github.io/website/"><span>
      <svg height="22px" version="1.1" viewBox="0 0 20 19" width="22px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title></title><desc></desc><defs></defs><g fill="none" fill-rule="evenodd" id="Page-1" stroke="none" stroke-width="1"><g fill="#000000" id="Core" transform="translate(-506.000000, -255.000000)"><g id="home" transform="translate(506.000000, 255.500000)"><path d="M8,17 L8,11 L12,11 L12,17 L17,17 L17,9 L20,9 L10,0 L0,9 L3,9 L3,17 L8,17 Z" id="Shape"></path></g></g></g></svg>
    </span></a>
  <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#sitenav" aria-controls="sitenav" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="sitenav">
    <ul class="navbar-nav ml-auto">
      <li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="TeoríaBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teoría</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/clases/">Clases</a></li>
          </ul>
      </li><li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="LabsBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Labs</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/labs/fork/">fork</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/labs/shell/">shell</a></li>
          </ul>
      </li><li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="TPsBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">TPs</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/tps/malloc">malloc</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/tps/sched">sched</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/tps/filesystem">filesystem</a></li>
          </ul>
      </li><li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="EnlacesBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Enlaces</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/calendario/">Calendario</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/regimen/">Régimen</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/entregas/">Entregas</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/bibliografia/">Bibliografía</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/kit/">Software</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/vm/">Entorno</a></li>
          </ul>
      </li><li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="ExtraBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Extra</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/labs/unix/">unix</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/labs/proc/">proc</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/labs/locks/">locks</a></li>
          </ul>
      </li><li class="nav-item dropdown open-on-hover">
        <a class="nav-link dropdown-toggle p-sm-3 d-block" href="https://fisop.github.io/website/labs/shell/#" role="button" id="AcercaBtn" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Acerca</a>
        <ul class="dropdown-menu">
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/contacto/">Contacto</a></li>
          <li><a class="nav-link dropdown-item" href="https://fisop.github.io/website/docentes/">Docentes</a></li>
          </ul>
      </li></ul>
  </div>
</nav>

    </header>

    <main role="main" class="row justify-content-center pt-sm-4">
      <article class="col">
  <h1 id="lab-shell">Lab shell</h1>

<p>El propósito de este <em>lab</em> es el de desarrollar la funcionalidad mínima que caracteriza a un intérprete de comandos <em>shell</em> similar a lo que realizan <code class="language-plaintext highlighter-rouge">bash</code>, <code class="language-plaintext highlighter-rouge">zsh</code>, <code class="language-plaintext highlighter-rouge">fish</code>.</p>

<p>La implementación debe realizarse en C11 y POSIX.1-2008. <em>(Estas siglas hacen referencia a la versión del lenguaje C utilizada y del estándar de syscalls Unix empleado. Las versiones modernas de GCC y Linux cumplen con ambos requerimientos.)</em></p>

<p class="alert alert-primary">A efectos de lo explicado en la <a href="https://fisop.github.io/website/entregas/">página de entregas</a>, el esqueleto para este lab se encuentra en el repositorio <a href="https://github.com/fisop/labs" class="alert-link"><code class="language-plaintext highlighter-rouge">https://github.com/fisop/labs</code></a>, rama <strong><em>shell</em></strong> (la cual no necesita ninguna integración previa).</p>

<p class="alert alert-warning"><strong>IMPORTANTE</strong>: leer el archivo <code class="language-plaintext highlighter-rouge">README.md</code> que se encuentra en la raíz del proyecto. Contiene información sobre cómo realizar la compilación de los archivos, y cómo ejecutar el formateo de código.</p>

<p class="alert alert-danger"><strong>REQUERIDO</strong>: para las entregas es condición <strong>necesaria</strong> que el <em>check</em> del <strong>formato</strong> de código esté en verde a la hora de realizar el PR (<em>pull request</em>). Para ello, se puede ejecutar <code class="language-plaintext highlighter-rouge">make format</code> localmente, comitear y subir esos cambios.</p>

<h2 class="no_toc d-md-none" id="índice">Índice</h2>

<ul class="sidetoc d-md-none" id="markdown-toc">
  <li><a href="https://fisop.github.io/website/labs/shell/#skel" id="markdown-toc-skel">Esqueleto</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#depurando-con-printf" id="markdown-toc-depurando-con-printf">Depurando con printf</a></li>
    </ul>
  </li>
  <li><a href="https://fisop.github.io/website/labs/shell/#exec" id="markdown-toc-exec">Parte 1: Invocación de comandos</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#b%C3%BAsqueda-en-path" id="markdown-toc-búsqueda-en-path">Búsqueda en <em>$PATH</em></a>        <ul>
          <li><a href="https://fisop.github.io/website/labs/shell/#argumentos-del-programa" id="markdown-toc-argumentos-del-programa">Argumentos del programa</a></li>
        </ul>
      </li>
      <li><a href="https://fisop.github.io/website/labs/shell/#procesos-en-segundo-plano" id="markdown-toc-procesos-en-segundo-plano">Procesos en segundo plano</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#resumen" id="markdown-toc-resumen">Resumen</a></li>
    </ul>
  </li>
  <li><a href="https://fisop.github.io/website/labs/shell/#parte-2-redirecciones" id="markdown-toc-parte-2-redirecciones">Parte 2: Redirecciones</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#flujo-est%C3%A1ndar" id="markdown-toc-flujo-estándar">Flujo estándar</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#tuber%C3%ADas-simples-pipes" id="markdown-toc-tuberías-simples-pipes">Tuberías simples <em>(pipes)</em></a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#tuber%C3%ADas-m%C3%BAltiples" id="markdown-toc-tuberías-múltiples">Tuberías múltiples</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#resumen-1" id="markdown-toc-resumen-1">Resumen</a></li>
    </ul>
  </li>
  <li><a href="https://fisop.github.io/website/labs/shell/#parte-3-variables-de-entorno" id="markdown-toc-parte-3-variables-de-entorno">Parte 3: Variables de entorno</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#expandvar" id="markdown-toc-expandvar">Expansión de variables</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#variables-de-entorno-temporarias" id="markdown-toc-variables-de-entorno-temporarias">Variables de entorno temporarias</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#pseudo-variables" id="markdown-toc-pseudo-variables">Pseudo-variables</a></li>
      <li><a href="https://fisop.github.io/website/labs/shell/#resumen-2" id="markdown-toc-resumen-2">Resumen</a></li>
    </ul>
  </li>
  <li><a href="https://fisop.github.io/website/labs/shell/#parte-4-extras" id="markdown-toc-parte-4-extras">Parte 4: Extras</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#comandos-built-in" id="markdown-toc-comandos-built-in">Comandos <em>built-in</em></a></li>
    </ul>
  </li>
  <li><a href="https://fisop.github.io/website/labs/shell/#desaf%C3%ADos" id="markdown-toc-desafíos">Desafíos</a>    <ul>
      <li><a href="https://fisop.github.io/website/labs/shell/#navegacion-historial" id="markdown-toc-navegacion-historial">Navegación por el historial</a></li>
    </ul>
  </li>
</ul>

<h2 id="skel">Esqueleto</h2>

<p>Para que no tengan que implementar todo desde cero, se provee un esqueleto de shell. Éste tiene gran parte del parseo hecho, y está estructurado indicando con comentarios los lugares en donde deben introducir el código crítico de cada punto.</p>

<p>Se recomienda antes de empezar leer el código para entender bien cómo funciona, y qué hace cada una de las funciones. <strong>Particularmente recomendamos entender qué significa cada uno de los campos en los structs de <code class="language-plaintext highlighter-rouge">types.h</code></strong>.</p>

<h3 id="depurando-con-printf">Depurando con printf</h3>

<p>Es importante mencionar que es requisito usar las funciones <code class="language-plaintext highlighter-rouge">printf_debug</code> y <code class="language-plaintext highlighter-rouge">fprintf_debug</code> si se desea mostrar información por pantalla; o bien encapsular todo lo que se imprima por stdout o stderr utilizando la macro <code class="language-plaintext highlighter-rouge">SHELL_NO_INTERACTIVE</code> (como ejemplo, ver las funciones definidas en <code class="language-plaintext highlighter-rouge">utils.c</code>).</p>

<p>Esto es debido a que al momento de corregir es mucho más fácil ejecutar una shell en modo no interactivo (que no imprima <em>prompt</em>) y así poder comparar el output de forma automática.</p>

<p class="alert alert-info">Cualquier mensaje que se imprima por pantalla al momento de hacer la entrega tiene que hacerse con las funciones <code class="language-plaintext highlighter-rouge">printf_debug</code> (en lugar de <code class="language-plaintext highlighter-rouge">printf</code>) o bien encapsulando el código con la directiva del preprocesador <code class="language-plaintext highlighter-rouge">#ifndef SHELL_NO_INTERACTIVE</code>.</p>

<h2 id="exec">Parte 1: Invocación de comandos</h2>

<h3 id="búsqueda-en-path">Búsqueda en <em>$PATH</em></h3>

<p>Los comandos que usualmente se utilizan, como los realizados en el <em>lab</em> anterior, están guardados (sus binarios), en el directorio <em>/bin</em>. Por este motivo existe una variable de entorno llamada <em>$PATH</em>, en la cual se declaran las rutas más usualmente accedidas por el sistema operativo (ejecutar: <code class="language-plaintext highlighter-rouge">echo $PATH</code> para ver la totalidad de las rutas almacenadas). Se pide agregar la funcionalidad de poder invocar comandos, cuyos binarios se encuentren en las rutas especificadas en la variable <em>$PATH</em>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">uptime
 </span>05:45:25 up 5 days, 12:02,  5 <span class="nb">users</span>,  load average: ...
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Ejecución de programas.</li>
  <li><em><u>Responder:</u></em> ¿cuáles son las diferencias entre la <em>syscall</em> <code class="language-plaintext highlighter-rouge">execve(2)</code> y la familia de <em>wrappers</em> proporcionados por la librería estándar de <em>C</em> (<em>libc</em>) <code class="language-plaintext highlighter-rouge">exec(3)</code>?</li>
  <li><em><u>Responder:</u></em> ¿Puede la llamada a <code class="language-plaintext highlighter-rouge">exec(3)</code> fallar? ¿Cómo se comporta la implementación de la <em>shell</em> en ese caso?</li>
</ul>

<h4 id="argumentos-del-programa">Argumentos del programa</h4>

<p>En esta parte del lab, vamos a incorporar a la invocación de comandos, la funcionalidad de poder pasarle <em>argumentos</em> al momento de querer ejecutarlos. Los argumentos pasados al programa de esta forma, se guardan en la famosa variable <strong>char* argv[]</strong>, junto con cuántos fueron en <strong>int argc</strong>, declaradas en el <em>main</em> de cualquier programa en <em>C</em>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">df</span> <span class="nt">-H</span> /tmp
Filesystem      Size  Used Avail Use% Mounted on
tmpfs           8.3G  2.0M  8.3G   1% /tmp
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Ejecución de programas con argumentos (<code class="language-plaintext highlighter-rouge">argv[]</code>).</li>
</ul>

<p><strong>Función sugerida:</strong>  <code class="language-plaintext highlighter-rouge">execvp(3)</code></p>

<p><strong>Archivo:</strong> <code class="language-plaintext highlighter-rouge">exec_cmd()</code> en <em>exec.c</em></p>

<h3 id="procesos-en-segundo-plano">Procesos en segundo plano</h3>

<p>Los procesos en segundo plano o procesos en el fondo, o <em>background</em>, son muy útiles a la hora de ejecutar comandos que no queremos esperar a que terminen para que la <em>shell</em> nos devuelva el <em>prompt</em> nuevamente. Por ejemplo si queremos ver algún documento <em>.pdf</em> o una imagen y queremos seguir trabajando en la terminal sin tener que abrir una nueva.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>evince file.pdf &amp;
 <span class="o">[</span><span class="nv">PID</span><span class="o">=</span>2489]

<span class="nv">$ </span><span class="nb">ls</span> /home
patricio
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Sólo se pide la implementación de un proceso en segundo plano. No es necesario
que se notifique de la terminación del mismo por medio de mensajes en la
<em>shell</em>.</p>

<p>Sin embargo, la <em>shell</em> deberá <strong>esperar oportunamente</strong> a los procesos en segundo plano. Esto puede hacerse sincrónicamente antes de mostrar cada prompt, pero el objetivo es que en una ejecución normal <em>no se dejen procesos huérfanos</em>.</p>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Procesos en segundo plano. Sin notificación de procesos terminados, pero esperando <em>oportunísticamente</em> con cada <em>prompt</em> a los procesos en segundo plano.</li>
  <li><em><u>Responder:</u></em> Detallar cuál es el mecanismo utilizado para implementar procesos en segundo plano.</li>
</ul>

<p><strong>Ayuda:</strong> Leer el funcionamiento del flag <code class="language-plaintext highlighter-rouge">WNOHANG</code> de la syscall <code class="language-plaintext highlighter-rouge">wait(2)</code></p>

<h3 id="resumen">Resumen</h3>

<p>Al finalizar la parte 1 la <em>shell</em> debe poder:</p>
<ul>
  <li>Invocar programas y permitir pasarles argumentos.</li>
  <li>Esperar correctamente a la ejecución de los programas.</li>
  <li>Ejecutar procesos en segundo plano.</li>
  <li>Esperar <em>oportunísticamente</em> a los procesos en segundo plano antes de cada prompt.</li>
</ul>

<h2 id="parte-2-redirecciones">Parte 2: Redirecciones</h2>

<h3 id="flujo-estándar">Flujo estándar</h3>

<p>La redirección del flujo estándar es una de las cualidades más interesantes y valiosas de una <em>shell</em> moderna. Permite, entre otras cosas, almacenar la salida de un programa en un archivo de texto para luego poder analizarla, como así también ejecutar un programa y enviarle un archivo a su entrada estándar. Existen, básicamente tres formas de redirección del flujo estándar:</p>

<ul>
  <li>
    <p><strong><u>Entrada y Salida estándares a archivos</u></strong> <em>(<code class="language-plaintext highlighter-rouge">&lt;in.txt</code> <code class="language-plaintext highlighter-rouge">&gt;out.txt</code>)</em></p>

    <p>Son los operadores clásicos del manejo de la redirección del <em>stdin</em> y el <em>stdout</em> en archivos de entrada y salida respectivamente. Por ejemplo:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> /usr
bin etc games include lib <span class="nb">local </span>sbin share src

<span class="nv">$ </span><span class="nb">ls</span> /usr <span class="o">&gt;</span>out1.txt
<span class="nv">$ </span><span class="nb">cat </span>out1.txt
bin etc games include lib <span class="nb">local </span>sbin share src

<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-w</span> &lt;out1.txt
10

<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-C</span> /sys /noexiste <span class="o">&gt;</span>out2.txt
<span class="nb">ls</span>: cannot access <span class="s1">'/noexiste'</span>: No such file or directory

<span class="nv">$ </span><span class="nb">cat </span>out2.txt
/sys:
block  class  devices	 fs  kernel  module  power

<span class="nv">$ </span><span class="nb">wc</span> <span class="nt">-w</span> &lt;out2.txt
8
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Se puede ver cómo queda implícito que cuando se utiliza el operador <strong>&gt;</strong> se refiere al <em>stdout</em> y cuando se utiliza el <strong>&lt;</strong> se refiere al <em>stdin</em>.</p>
  </li>
  <li>
    <p><strong><u>Error estándar a archivo</u></strong> <em>(<code class="language-plaintext highlighter-rouge">2&gt;err.txt</code>)</em></p>

    <p>Es una de las dos formas de redireccionar el <em>flujo estándar de error</em> análogo al caso anterior del flujo de salida estándar en un archivo de texto. Por ejemplo:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-C</span> /home /noexiste <span class="o">&gt;</span>out.txt 2&gt;err.txt

<span class="nv">$ </span><span class="nb">cat </span>out.txt
/home:
patricio

<span class="nv">$ </span><span class="nb">cat </span>err.txt
<span class="nb">ls</span>: cannot access <span class="s1">'/noexiste'</span>: No such file or directory
</pre></td></tr></tbody></table></code></pre></div>    </div>

    <p>Como se puede observar, <code class="language-plaintext highlighter-rouge">ls</code> no informa ningún error al finalizar, como sí lo hacía en el ejemplo anterior. Su salida estándar de error ha sido redireccionada al archivo <em>err.txt</em></p>
  </li>
  <li>
    <p><strong><u>Combinar salida y errores</u></strong> <em>(<code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>)</em></p>

    <p>Es la segunda forma de redireccionar el flujo estándar producido por errores en la ejecución de un programa. Su funcionamiento se puede observar a través del siguiente ejemplo:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-C</span> /home /noexiste <span class="o">&gt;</span>out.txt 2&gt;&amp;1

<span class="nv">$ </span><span class="nb">cat </span>out.txt
<span class="nt">---</span>????---
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>Existen más tipos de redirecciones que nuestra <em>shell</em> no soportará (e.g. <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> o <code class="language-plaintext highlighter-rouge">&amp;&gt;</code>)</p>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> <em>Al menos</em>, soporte para cada una de las <strong>tres formas de redirección</strong> descritas arriba: <code class="language-plaintext highlighter-rouge">&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">2&gt;</code> y <code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>.</li>
  <li><em><u>Responder:</u></em> Investigar el significado de <code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code>, explicar cómo funciona su <em>forma general</em> y mostrar qué sucede con la salida de <code class="language-plaintext highlighter-rouge">cat out.txt</code> en el ejemplo. Luego repetirlo invertiendo el orden de las redirecciones. ¿Cambió algo?</li>
</ul>

<p><strong>Ayuda:</strong> Pueden valerse de las páginas del manual de bash: <code class="language-plaintext highlighter-rouge">man bash</code>.</p>

<p><strong>Syscalls sugeridas:</strong> <code class="language-plaintext highlighter-rouge">dup2(2)</code>, <code class="language-plaintext highlighter-rouge">open(2)</code></p>

<p><strong>Archivo:</strong> <code class="language-plaintext highlighter-rouge">open_redir_fd()</code> en <em>exec.c</em> y usarla en <code class="language-plaintext highlighter-rouge">exec_cmd()</code></p>

<h3 id="tuberías-simples-pipes">Tuberías simples <em>(pipes)</em></h3>

<p>Al igual que la redirección del flujo estándar hacia archivos, es igual o más importante, la redirección hacia otros programas. La forma de hacer esto en una <em>shell</em> es mediante el operador <code class="language-plaintext highlighter-rouge">|</code> (<em>pipe</em> o <em>tubería</em>). De esta forma se pueden concatenar dos o más programas para que la salida estándar de uno se redirija a la entrada estándar del siguiente. Por ejemplo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">grep </span>Doc
drwxr-xr-x  7 patricio patricio  4096 mar 26 01:20 Documentos
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Soporte para <strong>pipes</strong> entre dos comandos.
    <ul>
      <li>La shell debe esperar a que <em>ambos procesos</em> terminen antes de devolver el prompt: <code class="language-plaintext highlighter-rouge">echo hi | sleep 5</code> y <code class="language-plaintext highlighter-rouge">sleep 5 | echo hi</code> <em>ambos</em> deben esperar 5 segundos.</li>
      <li>Los procesos de cada lado del pipe no deben quedar con <em>fds</em> de más.</li>
      <li>Los procesos deben ser lanzados <em>en simultáneo</em>.</li>
    </ul>
  </li>
</ul>

<p><strong>Syscalls sugeridas:</strong> <code class="language-plaintext highlighter-rouge">pipe(2)</code>, <code class="language-plaintext highlighter-rouge">dup2(2)</code></p>

<p><strong>Archivo:</strong> <code class="language-plaintext highlighter-rouge">exec_cmd()</code> en <em>exec.c</em></p>

<h3 id="tuberías-múltiples">Tuberías múltiples</h3>

<p>Extender el funcionamiento de la <em>shell</em> para que se puedan ejecutar <em>n</em> comandos concatenados.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-l</span> | <span class="nb">grep </span>Doc | <span class="nb">wc
     </span>1       9      64
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Soporte para <strong>múltiples pipes</strong> anidados.</li>
  <li><em><u>Responder:</u></em> Investigar qué ocurre con el <em>exit code</em> reportado por la <em>shell</em> si se ejecuta un pipe ¿Cambia en algo? ¿Qué ocurre si, en un pipe, alguno de los comandos falla? Mostrar evidencia (e.g. salidas de terminal) de este comportamiento usando <code class="language-plaintext highlighter-rouge">bash</code>. Comparar con la implementación del este lab.</li>
</ul>

<p><strong>Hint:</strong> Las modificaciones necesarias sólo atañen a la función <code class="language-plaintext highlighter-rouge">parse_line()</code> en <em>parsing.c</em></p>

<h3 id="resumen-1">Resumen</h3>

<p>Al finalizar la parte 2 la <em>shell</em> debe poder:</p>
<ul>
  <li>Redireccionar la entrada y salida estándar de los programas vía <code class="language-plaintext highlighter-rouge">&lt;</code>, <code class="language-plaintext highlighter-rouge">&gt;</code> y <code class="language-plaintext highlighter-rouge">2&gt;</code>.
    <ul>
      <li>Además se soporta específicamente la redirección de tipo <code class="language-plaintext highlighter-rouge">2&gt;&amp;1</code></li>
    </ul>
  </li>
  <li>Concatenar la ejecución de dos o más programas mediante <em>pipes</em></li>
</ul>

<h2 id="parte-3-variables-de-entorno">Parte 3: Variables de entorno</h2>

<h3 id="expandvar">Expansión de variables</h3>

<p>Una característica de cualquier intérprete de comandos <em>shell</em> es la de expandir variables de entorno (ejecutar: <code class="language-plaintext highlighter-rouge">env</code> para ver una lista completa de las variables de entorno definidas), como  <strong>PATH</strong>, o <strong>HOME</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$TERM</span>
xterm-16color
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Las variables de entorno se indican con el caracter <code class="language-plaintext highlighter-rouge">$</code> antes del nombre, y la <em>shell</em> se encarga de <em>reemplazar</em> en la línea leída todos los tokens que comiencen por <code class="language-plaintext highlighter-rouge">$</code> por los valores correspondientes del entorno. Esto ocurre <em>antes</em> de que el proceso sea ejecutado.</p>

<ul class="alert alert-info">
  <li><em><u>Implementar:</u></em> Expansión de variables al ejecutar un comando. Se debe reemplazar las variables que no existan con una cadena vacía (<code class="language-plaintext highlighter-rouge">""</code>).</li>
</ul>

<p>Las variables vacías y las variables no setteadas <em>no deben</em> traducirse a
argumentos en el <code class="language-plaintext highlighter-rouge">exec</code>. Por ejemplo <code class="language-plaintext highlighter-rouge">echo hola $VARIABLE_VACIA mundo</code> es
equivalente a <code class="language-plaintext highlighter-rouge">echo "hola" "mundo"</code>, dos argumentos solamente.</p>

<p><strong>Función sugerida:</strong> <code class="language-plaintext highlighter-rouge">getenv(3)</code></p>

<p><strong>Archivos:</strong> <code class="language-plaintext highlighter-rouge">expand_environ_var()</code> y <code class="language-plaintext highlighter-rouge">parse_exec()</code> en <em>parsing.c</em>,</p>

<h3 id="variables-de-entorno-temporarias">Variables de entorno temporarias</h3>

<p>En esta parte se va a extender la funcionalidad de la <em>shell</em> para que soporte el poder incorporar nuevas variables de entorno a la ejecución de un programa. Cualquier programa que hagamos en C, por ejemplo, tiene acceso a todas las variables de entorno definidas mediante la variable externa <em>environ</em> (<code class="language-plaintext highlighter-rouge">extern char** environ</code>).</p><div class="bigfoot-footnote__container"> <button class="bigfoot-footnote__button" id="fnref:noinc" data-footnote-number="1" data-footnote-identifier="1" alt="See Footnote 1" rel="footnote" data-bigfoot-footnote="&lt;p&gt;No es necesario realizar el &lt;em&gt;include&lt;/em&gt; de ningún header para hacer uso de esta variable.&lt;/p&gt;"> <svg class="bigfoot-footnote__button__circle" viewBox="0 0 6 6" preserveAspectRatio="xMinYMin"><circle r="3" cx="3" cy="3" fill="white"></circle></svg> <svg class="bigfoot-footnote__button__circle" viewBox="0 0 6 6" preserveAspectRatio="xMinYMin"><circle r="3" cx="3" cy="3" fill="white"></circle></svg> <svg class="bigfoot-footnote__button__circle" viewBox="0 0 6 6" preserveAspectRatio="xMinYMin"><circle r="3" cx="3" cy="3" fill="white"></circle></svg> </button></div><sup id="fnref:noinc" role="doc-noteref" data-footnote-backlink-ref="fnref:noinc" data-footnote-ref="#fn:noinc" class="footnote-print-only"><a href="https://fisop.github.io/website/labs/shell/#fn:noinc" class="footnote" rel="footnote">1</a></sup><p></p>

<p>Se pide, entonces, la posibilidad de incorporar de forma dinámica nuevas variables, por ejemplo:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>/usr/bin/env
<span class="nt">---</span> todas las variables de entorno definidas hasta el momento <span class="nt">---</span>

<span class="nv">$ USER</span><span class="o">=</span>nadie <span class="nv">ENTORNO</span><span class="o">=</span>nada /usr/bin/env | <span class="nb">grep</span> <span class="o">=</span>nad
<span class="nv">USER</span><span class="o">=</span>nadie
<span class="nv">ENTORNO</span><span class="o">=</span>nada
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><u>Implementar:</u> Variables de entorno temporales.</li>
  <li><em><u>Pregunta</u>:</em> ¿Por qué es necesario hacerlo luego de la llamada a <code class="language-plaintext highlighter-rouge">fork(2)</code>?</li>
  <li><em><u>Pregunta</u>:</em> En algunos de los <em>wrappers</em> de la familia de funciones de <code class="language-plaintext highlighter-rouge">exec(3)</code> (las que finalizan con la letra <em>e</em>), se les puede pasar un tercer argumento (o una lista de argumentos dependiendo del caso), con nuevas variables de entorno para la ejecución de ese proceso.
Supongamos, entonces, que en vez de utilizar <code class="language-plaintext highlighter-rouge">setenv(3)</code> por cada una de las variables, se guardan en un array y se lo coloca en el tercer argumento de una de las funciones de <code class="language-plaintext highlighter-rouge">exec(3)</code>.
    <ul>
      <li>¿El comportamiento resultante es el mismo que en el primer caso? Explicar qué sucede y por qué.</li>
      <li>Describir brevemente (sin implementar) una posible implementación para que el comportamiento sea el mismo.</li>
    </ul>
  </li>
</ul>

<p><strong>Ayuda:</strong> luego de llamar a <code class="language-plaintext highlighter-rouge">fork(2)</code> realizar, por cada una de las variables de entorno a agregar, una llamada a <code class="language-plaintext highlighter-rouge">setenv(3)</code>.</p>

<p><strong>Función sugerida:</strong> <code class="language-plaintext highlighter-rouge">setenv(3)</code></p>

<p><strong>Archivo:</strong> implementar <code class="language-plaintext highlighter-rouge">set_environ_vars()</code> en <em>exec.c</em> y usarla en <code class="language-plaintext highlighter-rouge">exec_cmd()</code></p>

<h3 id="pseudo-variables">Pseudo-variables</h3>

<p>Existen las denominadas variables de entorno <em>mágicas</em>, o pseudo-variables. Estas variables son propias del <em>shell</em> (no están formalmente en <em>environ</em>) y cambian su valor dinámicamente a lo largo de su ejecución. Implementar <strong><code class="language-plaintext highlighter-rouge">?</code></strong> como única variable <em>mágica</em> (describir, también, su propósito).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="nv">$ </span>/bin/true
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
0

<span class="nv">$ </span>/bin/false
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
1
</pre></td></tr></tbody></table></code></pre></div></div>

<ul class="alert alert-info">
  <li><u>Implementar:</u> Soporte para para la <em>pseudo-variable</em> <code class="language-plaintext highlighter-rouge">$?</code>. Esto implicará actualizar correctamente la variable <em>global</em> <code class="language-plaintext highlighter-rouge">status</code> cuando se ejecute un <em>built-in</em> (ya que los mismos no corren en procesos separados).</li>
  <li><em><u>Pregunta</u>:</em> Investigar al menos otras tres variables mágicas estándar, y describir su propósito. Incluir un ejemplo de su uso en <code class="language-plaintext highlighter-rouge">bash</code> (u otra terminal similar).</li>
</ul>

<p><strong>Archivo:</strong> <code class="language-plaintext highlighter-rouge">expand_environ_var()</code> en <em>parsing.c</em>, ver también la variable <em>global</em> <code class="language-plaintext highlighter-rouge">status</code>.</p>

<h3 id="resumen-2">Resumen</h3>

<p>Al finalizar la parte 3 la <em>shell</em> debe poder:</p>
<ul>
  <li>Expandir variables de entorno</li>
  <li>Incluyendo la pseudo-variable <code class="language-plaintext highlighter-rouge">$?</code></li>
  <li>Ejecutar procesos con variables de entorno adicionales</li>
</ul>

<h2 id="parte-4-extras">Parte 4: Extras</h2>

<h3 id="comandos-built-in">Comandos <em>built-in</em></h3>

<p>Los comandos <em>built-in</em> nos dan la oportunidad de realizar acciones que no siempre podríamos hacer si ejecutáramos ese mismo comando en un proceso separado. Éstos son propios de cada <em>shell</em> aunque existe un estándar generalizado entre los diferentes intérpretes, como por ejemplo <code class="language-plaintext highlighter-rouge">cd</code> y <code class="language-plaintext highlighter-rouge">exit</code>.</p>

<p>Es evidente que si <code class="language-plaintext highlighter-rouge">cd</code> no se realizara en el mismo proceso donde la <em>shell</em> se está ejecutando, no tendría el efecto deseado, ya que el directorio actual se cambiaría en el hijo, y no en el padre que es lo que realmente queremos. Lo mismo se aplica a <code class="language-plaintext highlighter-rouge">exit</code> y a muchos comandos más (<a href="https://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands">aquí</a> se muestra una lista completa de los comando <em>built-in</em> que soporta <em>bash</em>).</p>

<ul class="alert alert-info">
  <li><em><u>Implementar</u></em>: Los <em>built-ins</em>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">cd</code> - <em>change directory</em> (cambia el directorio actual)</li>
      <li><code class="language-plaintext highlighter-rouge">exit</code> - exits nicely (termina una terminal de forma <em>linda</em>)</li>
      <li><code class="language-plaintext highlighter-rouge">pwd</code> - <em>print working directory</em> (muestra el directorio actual de trabajo)</li>
    </ul>
  </li>
  <li><em><u>Pregunta</u></em>: ¿Entre <code class="language-plaintext highlighter-rouge">cd</code> y <code class="language-plaintext highlighter-rouge">pwd</code>, alguno de los dos se podría implementar sin necesidad de ser <em>built-in</em>? ¿Por qué? ¿Si la respuesta es sí, cuál es el motivo, entonces, de hacerlo como <em>built-in</em>? (para esta última pregunta pensar en los <em>built-in</em> como <code class="language-plaintext highlighter-rouge">true</code> y <code class="language-plaintext highlighter-rouge">false</code>)</li>
</ul>

<p><strong>Funciones sugeridas:</strong> <code class="language-plaintext highlighter-rouge">chdir(3)</code>, <code class="language-plaintext highlighter-rouge">exit(3)</code>, <code class="language-plaintext highlighter-rouge">getcwd(3)</code></p>

<p><strong>Archivo:</strong> <code class="language-plaintext highlighter-rouge">cd()</code>, <code class="language-plaintext highlighter-rouge">exit_shell()</code> y <code class="language-plaintext highlighter-rouge">pwd()</code> en <em>builtin.c</em></p>

<h2 id="desafíos">Desafíos</h2>

<p class="alert alert-warning">Las tareas listadas aquí no son obligatorias, pero suman para el régimen de <a href="https://fisop.github.io/website/regimen/#final">final alternativo</a>.</p>

<!---
### Segundo plano avanzado (challenge opcional)

```
$ sleep 2 &
PID=2489

$ sleep 5
<pasan dos segundos, y entonces:

==> terminado: PID=2489

:ahora pasan otros tres segundos antes de retornar>
$
```

En otras palabras, se notifica de la terminación en cuanto ocurre, sin esperar al siguiente prompt como en la parte 1.

También se observa el comportamiento en la ausencia de un segundo comando en primer plano; simplemente, se escribiría en la línea del _prompt_ actual:

```
$ sleep 2 &
PID=2489

$ ==> terminado: PID=2489
 ^
 dos segundos después, se imprime a continuación del prompt
```

Se recomienda, de hecho, realizar las primeras pruebas con este segundo ejemplo, para trabajar con una sola señal SIGCHLD.

Una vez hecho eso, se debe resolver el problema de que los procesos foreground también generan SIGCHLD, y el handler los aceptaría, quedando el _waitpid_ de `run_cmd()` incapaz de obtener el estado de salida del hijo. La solución más fácil es asegurarse de que todos los procesos en segundo plano tengan un mismo _process group_, y que la llamada a _waitpid_ en el manejador de la señal no use -1 como argumento, sino un valor numérico que restrinja la llamada a los procesos en segundo plano. (Sugerencia: configurar el uso de grupos tal que ese primer argumento de _waitpid_ pueda ser, sencillamente, 0.)

_<u>Preguntas:</u>_

- Explicar detalladamente cómo se manejó la terminación del mismo.

- ¿Por qué es necesario el uso de señales?

**Syscalls sugeridas:** `setpgid(2)`, `sigaction(2)`, `sigaltstack(2)`

**Archivos:** _exec.c_, _runcmd.c_, _sh.c_
--->

<h3 id="navegacion-historial">Navegación por el historial</h3>

<p>Implementar el comando built-in <code class="language-plaintext highlighter-rouge">history</code>, el mismo muestra la lista de comandos ejecutados
hasta el momento. De proporcionarse como argumento <code class="language-plaintext highlighter-rouge">n</code>, un número entero, solamente mostrar los
últimos <code class="language-plaintext highlighter-rouge">n</code> comandos.</p>

<p>De estar definida la variable de entorno <strong>HISTFILE</strong>, la misma contendrá la ruta al archivo
con los comandos ejecutados en el pasado. En caso contrario, utilizar como ruta por omisión a <em>~/.fisop_history</em>.</p>

<p>Permitir navegar el historial de comandos con las teclas ↑ y ↓, de modo tal que se
pueda volver a ejecutar alguno de ellos. Con la tecla ↑ se accede a un comando anterior,
y con la tecla ↓ a un comando posterior, si este último no existe, eliminar el comando
actual de modo que solo se vea el prompt.</p>

<p>La tecla BackSpace debe funcionar para borrar los caracteres de un comando de hasta una línea de largo. Al presionar Ctrl&nbsp;+&nbsp;d, la shell debe terminar su ejecución.</p>

<p><strong>Ayuda</strong>:</p>

<ul>
  <li>Para tener mayor control sobre la entrada de caracteres, la terminal debe configurarse en
modo no canónico y sin eco. Puede usar como guía el ejemplo <a href="https://www.gnu.org/software/libc/manual/html_node/Noncanon-Example.html">Noncanonical Mode</a>
presente en <a href="https://www.gnu.org/software/libc/manual/html_node/Low_002dLevel-Terminal-Interface.html">Low-Level Terminal Interface</a>.</li>
  <li>Pueden ser de utilidad algunas <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">secuencias de escape ANSI</a>.</li>
  <li>Puede obtener información sobre la terminal con la llamada al sistema ioctl, ver: <a href="https://man7.org/linux/man-pages/man4/tty_ioctl.4.html">ioctl_tty(2)</a>.</li>
</ul>

<p><strong>Responder</strong>:</p>

<ul>
  <li>¿Cuál es la función de los parámetros <code class="language-plaintext highlighter-rouge">MIN</code> y <code class="language-plaintext highlighter-rouge">TIME</code> del modo no canónico? ¿Qué se logra en el ejemplo
dado al establecer a <code class="language-plaintext highlighter-rouge">MIN</code> en <code class="language-plaintext highlighter-rouge">1</code> y a <code class="language-plaintext highlighter-rouge">TIME</code> en <code class="language-plaintext highlighter-rouge">0</code>?</li>
</ul>

<p><strong>Debe completar al menos una de las siguientes consignas</strong>:</p>

<ul>
  <li>Permitir borrar con la tecla BackSpace los caracteres de un comando de cualquier número de líneas, independientemente que la escritura del mismo haya ocasionado el desplazamiento de la pantalla, esto ocurre al continuar escribiendo tras alcanzar la posición inferior derecha de la terminal.</li>
  <li>Desplazar el cursor de a un caracter con las teclas ← y →, de a una palabra con Ctrl&nbsp;+&nbsp;← y Ctrl&nbsp;+&nbsp;→, al comienzo del comando con Home, y al final del mismo con End, permitiendo insertar nuevos caracteres en cualquier posición.</li>
  <li>Implementar los designadores de eventos <code class="language-plaintext highlighter-rouge">!!</code> y <code class="language-plaintext highlighter-rouge">!-n</code>, ver sección <em>Event Designators</em> en <a href="https://www.man7.org/linux/man-pages/man1/bash.1.html">bash(1)</a>.</li>
</ul>

<script defer="" onload="$.bigfoot();" src="./shell.md_files/bigfoot.min.js.descarga"></script>

<link rel="stylesheet" href="./shell.md_files/bigfoot-default.min.css">

<div class="footnotes footnote-print-only" role="doc-endnotes">
  <ol class="footnote-print-only">
    <li id="fn:noinc" role="doc-endnote" class="footnote-processed footnote-print-only">
      <p>No es necesario realizar el <em>include</em> de ningún header para hacer uso de esta variable.&nbsp;<a href="https://fisop.github.io/website/labs/shell/#fnref:noinc" class="reversefootnote" role="doc-backlink">↩︎</a></p>
    </li>
  </ol>
</div>

</article>

    </main>

    <footer role="contentinfo" class="row">
      





  <div class="wrapper">
    <a style="float: left;" rel="license" title="© 2016-2018 Patricio Iribarne Catella" href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="./shell.md_files/by-sa.svg"></a>
    <a style="float: right;" rel="source" href="https://fisop.github.io/website/labs/shell.md"><img height="16" alt="Link to Markdown source" src="./shell.md_files/source-md.svg"></a>
  </div>

<!-- Bootstrap 4 includes. -->

<script src="./shell.md_files/jquery.slim.min.js.descarga" integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script>

<script src="./shell.md_files/bootstrap.bundle.min.js.descarga" integrity="sha384-6khuMg9gaYr5AxOqhkVIODVIvm9ynTT5J4V1cfthmT+emCG6yVmEZsRHdxlotUnm" crossorigin="anonymous"></script>

<script>
  // Copiar la tabla de contenidos de Kramdown al sidebar. Tras hacer esto,
  // añadimos la clase d-md-none a la tabla antigua, para que no se muestre
  // duplicada en las pantallas donde la sidebar es visible.
  let toc = $("#markdown-toc.sidetoc");
  if (toc.length) {
    // Hacer una copia, y marcarla con posición fija.
    toc.clone().removeAttr("id").addClass("sticky-top").appendTo("#sidetoc");

    // Marcar la tabla del cuerpo, y su h2, como no visibles.
    // FIXME: no asumir que el elemento anterior es un <h2> que hay que quitar.
    toc.addClass("d-md-none");
    toc.prev().addClass("d-md-none");

    // Hacer visible el sidebar y...
    $("#sidetoc").addClass("d-md-block");

    // ... ajustar las clases para que funcione con scrollspy.
    $("#sidetoc ul").addClass("nav flex-column");
    $("#sidetoc li").addClass("nav-item");
    $("#sidetoc a").addClass("nav-link");
    $("body").scrollspy({target: "#sidetoc"});
  }
</script>


    </footer>
  </div>
  </div>
  </div>
  


</div></body></html>